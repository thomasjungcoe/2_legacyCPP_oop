/***
 *      완전한 클래스
 * ==============================================================================
 * 잘못 사용하기엔 어렵게, 바랍게 사용하기엔 쉽게 구현하라.
 *      * 단일 책임 원칙 (Single Responsibility Principle)을 준수하여 사용하기 쉽게 만들어라
 *      * 암시적 정의를 차단하여 의도한 동작만 하게 하라
 *      * 최소 public 으로 구현하여 사용하기 쉽게 하라.
 *      * 완전한 생성자로 작성하여 사용하기 쉽고, 예외에 안전하게 하라
 *      * 완전한 함수로 코딩 계약과 상수성 계약을 만들어 사용자 실수을 최소화 하라.
 * 소유권 분쟁과 복사 부하가 없도록 구현하라.
 * 예외에 안전하게 구현하라. (예외 발생시 이전 상태를 복원하라.)
 * 새로운 타입을 설계하듯 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자, 형변환 연산자,
 *  연산자의 가시성을 조정하고, virtual 여부를 결정하라.
 * 
 * Modern C++:
 *  C++11~: 우측값 참조 (&&)와 이동 생성자와 이동 대입 연산자가 추가되어 이동 연산을 
 *      지원하며, 임시 개체 대입시 속도가 향상되었습니다. 이동 생성자와 이동 대입 
 *      연산자는 암시적으로 생성됩니다.
 *  C++11~: default, delete가 추가되어 암시적으로 생성되는 멤버 함수의 사용 여부를 좀더 
 *      명시적으로 정의할수 있습니다.
 *  C++11~: explicit 형변환 연산자가 추가되어 명시적으로 형변환 할수 있습니다.
 *  C++11~: final이 추가되어 가상 함수를 더이상 오버라이딩 못하게할수 있고, 강제적으로 
 *      상속을 제한할수 있습니다.
 * 
 *      개요
 * 클래스는 단일 책임 원칙 (Single Responsibilty Principle)에 따라 단 하나의 책임만 갖도록 
 *      설계하고, 단단한 코딩 계약에 의해 잘못 사용하기엔 어렵게, 바르게 사용하기엔 쉽게 
 *      구현해야 합니다 (캡슐화 참고)
 */

/*      암시적 정의 차단        */
/*      최소 public             */
/*     
         완전한 생성자
    개체가 생성될때 환전한 상태로 생성합니다.
    
    완전하지 않는 생성자는 다음과 같은 문제가 있습니다.

    1. 별도로 Setter 함수를 호출해야 하므로 사용하기 번거롭습니다. (초기화 리스트 참고)
    2. 기본값으로 대출 생성후 값을 세팅하면 불필요한 복사 대입 연산 오버헤드가 발생합니다 (초기화 리스트 참고)
    3. 개체 사용자는 개체 내부 구조를 완전히 파악해야만 제대로 사용할수 있습니다. 코딩 계약을 
        투명하게 하여 잘못 사용하기엔 어렵게, 바르게 사용하기엔 쉽게 구현해야 합니다 (캡슐와)
    4. 불완전하게 생성된 개체를 사용했을 때 발생하는 버그는 예측하기 힘듭니다.
    5. 불완전하게 생성된 개체에 별도 Setter 함수를 호출하여 완전하게 만드는 중에 예외가 발생하면,
        이미 생성된 예외 보증 처리를 위해 소멸시켜야 합니다. 혹시나 이미 이 개체를 참조하는 곳이 
        있다면, 처리가 곤란합니다. (초기화 리스트 참고)
    따라서,

    1. 개체 생성에 필요한 모든 인자를 생성자에서 나열하고,
    2. 생성중 오류가 발생하면 예외를 발생시켜 그동안 만들어 둔건 소멸시켜 버려야 합니다.
*/

/* 
        완전한 함수
함수 구현은 다음 사항을 준수하여야 합니다.
    1. 생성자와 마찬가지로 필요한 인자를 모두 전달하여야 합니다. 코딩 계약을 투명하게 하여 
        잘못 사용하기엔 어~~~
    2. 인자 전달이나 함수 리턴값 전달시 복사 부하를 최소화 해야 합니다.
    3. 상수성 계약을 위반하지 않도록 작성해야 합니다.
    4. 함수내에서 예외가 발생하면 그동안 만들어 두건 소멸시켜 버려야 합니다.
*/

/*
        소유권 분쟁 차단
포인터 멤버 변수 사용시에는 소유권 분쟁이 발생합니다.

소유권 분생이 발생하지 않도록 스마트 포인터(auto_ptr, unique_ptr, shared_ptr 등)를 사용하여,

1. 소유권 이전을 하거나 (auto_ptr, unique_ptr),
2. 깊은 복제를 하거나,
3. 자원을 공유하거나(shared_ptr)
4. 유일한 자원으로 대체해서 사용
*/

/*   자원 획득은 초기화
획득된 자원은 반드시 소멸되어야 하니다. (RAII (Resource Acquisition Is Initialization) 참고)
    소멸자에서 명시적으로 delete 하거나 스마트 포인터 (auto_ptr, unique_ptr, shared_ptr 등)를 
    이용할수 있습니다.
*/

/*   예외 안전에 좋은 클래스 설계   
예회가 발생하면, 예외가 발생하기 전의 상태로 돌아가야 합니다. 개체의 일부 내용만 복원하는게 
    아니라, 완전히 예외 발생 전의 상태로 되돌아 가야 합니다. (예외 보증 참고)
따라서, 예외에 대해 강한 보증을 해주어야 하며, 다음을 준수하시기 바랍니다.
1. 완전한 생성자로 생성하여 생성중 오류가 발생하면 예외를 발생시켜 그동안 만들어 둔건 
    소멸시켜 버리고,
2. 복사 실행중 예외가 발생하지 않도록 nothrow swap을 이용해서 복사 대입 연산을 구현하고,
3. 함수 실행중 예외가 발생하면, 스택 풀기 메카니즘에 맞게 이전 상태로 되돌리고,
4. 스택 풀기가 꼬이지 않게 소멸자에서는 예외가 발생하지 않도록 구현해야 합니다.
*/

/*  형변환 차단
암시적인 형변환은 제공하지 않습니다. 필요하다면 명시적으로 형변환 함수를 제공합니다.
    C++11~: explicit 형변환 연산자가 추가되어 명시적으로 형변환 할수있습니다.
*/

/*      부모 개체의 생성자와 복사 대입 연산자       */
/*
상속 특성에 맞게 protected 나 private 으로 제공합니다.

항목	                        내용
기본 생성자, 값 생성자	        상속 강제가 필요하므로 protected 생성자를 사용합니다.
복사 생성자	                    인터페이스라면 사용못하게 private로 막고, 추상 클래스라면 
                                    상황에 따라 protected나 private를 사용하고, 필요하면 
                                    Clone()가상 복사 생성자를 구현합니다.(가상 복사 생성자 참고)
복사 대입 연산자	            사용하지 못하게 private로 막습니다.(부모 개체의 복사 대입 연산자 참고)
*/

/*      부모 개체의 소멸자      
상속 특성에 맞게 적합한 소멸자를 사용합니다.

항목	                             내용
부모 개체로 사용하지 않는 개체	        상속하지 않음
                                      public Non-Virtual 소멸자 사용(상속 제한 참고)
is-a 관계	                          다형 소멸을 하려면 public Virtual 소멸자 사용
has-a 관계	                          protected Non-Virtual 소멸자 사용
추상 클래스	                           다형 소멸을 하려면 public Virtual 소멸자 사용
                                      다형 소멸이 필요 없으면 protected Non-Virtual 소멸자 사용
인터페이스	                            protected Non-Virtual 소멸자 사용




*/
